import * as a from "react";
import { l as u, s as F, R as K, L as M } from "./contexts-568EHGLp.mjs";
import { Room as N, RoomEvent as d, MediaDeviceFailure as x, ConnectionState as w } from "livekit-client";
function L(n) {
  var e, o, t = "";
  if (typeof n == "string" || typeof n == "number") t += n;
  else if (typeof n == "object") if (Array.isArray(n)) {
    var r = n.length;
    for (e = 0; e < r; e++) n[e] && (o = L(n[e])) && (t && (t += " "), t += o);
  } else for (o in n) n[o] && (t && (t += " "), t += o);
  return t;
}
function j() {
  for (var n, e, o = 0, t = "", r = arguments.length; o < r; o++) (n = arguments[o]) && (e = L(n)) && (t && (t += " "), t += e);
  return t;
}
function O(...n) {
  return (...e) => {
    for (const o of n)
      if (typeof o == "function")
        try {
          o(...e);
        } catch (t) {
          console.error(t);
        }
  };
}
function U(...n) {
  const e = { ...n[0] };
  for (let o = 1; o < n.length; o++) {
    const t = n[o];
    for (const r in t) {
      const l = e[r], f = t[r];
      typeof l == "function" && typeof f == "function" && // This is a lot faster than a regex.
      r[0] === "o" && r[1] === "n" && r.charCodeAt(2) >= /* 'A' */
      65 && r.charCodeAt(2) <= /* 'Z' */
      90 ? e[r] = O(l, f) : (r === "className" || r === "UNSAFE_className") && typeof l == "string" && typeof f == "string" ? e[r] = j(l, f) : e[r] = f !== void 0 ? f : l;
    }
  }
  return e;
}
const J = {
  connect: !0,
  audio: !1,
  video: !1
};
function T(n) {
  const {
    token: e,
    serverUrl: o,
    options: t,
    room: r,
    connectOptions: l,
    connect: f,
    audio: p,
    video: g,
    screen: v,
    onConnected: E,
    onDisconnected: R,
    onError: c,
    onMediaDeviceFailure: h,
    onEncryptionError: y,
    simulateParticipants: S,
    ...P
  } = { ...J, ...n };
  t && r && u.warn(
    "when using a manually created room, the options object will be ignored. set the desired options directly when creating the room instead."
  );
  const [i, D] = a.useState();
  a.useEffect(() => {
    D(r ?? new N(t));
  }, [r]);
  const A = a.useMemo(() => {
    const { className: s } = F();
    return U(P, { className: s });
  }, [P]);
  return a.useEffect(() => {
    if (!i) return;
    const s = () => {
      const m = i.localParticipant;
      u.debug("trying to publish local tracks"), Promise.all([
        m.setMicrophoneEnabled(!!p, typeof p != "boolean" ? p : void 0),
        m.setCameraEnabled(!!g, typeof g != "boolean" ? g : void 0),
        m.setScreenShareEnabled(!!v, typeof v != "boolean" ? v : void 0)
      ]).catch((C) => {
        u.warn(C), c == null || c(C);
      });
    }, b = (m) => {
      const C = x.getFailure(m);
      h == null || h(C);
    }, k = (m) => {
      y == null || y(m);
    };
    return i.on(d.SignalConnected, s).on(d.MediaDevicesError, b).on(d.EncryptionError, k), () => {
      i.off(d.SignalConnected, s).off(d.MediaDevicesError, b).off(d.EncryptionError, k);
    };
  }, [i, p, g, v, c, y, h]), a.useEffect(() => {
    if (i) {
      if (S) {
        i.simulateParticipants({
          participants: {
            count: S
          },
          publish: {
            audio: !0,
            useRealTracks: !0
          }
        });
        return;
      }
      if (!e) {
        u.debug("no token yet");
        return;
      }
      if (!o) {
        u.warn("no livekit url provided"), c == null || c(Error("no livekit url provided"));
        return;
      }
      f ? (u.debug("connecting"), i.connect(o, e, l).catch((s) => {
        u.warn(s), c == null || c(s);
      })) : (u.debug("disconnecting because connect is false"), i.disconnect());
    }
  }, [
    f,
    e,
    JSON.stringify(l),
    i,
    c,
    o,
    S
  ]), a.useEffect(() => {
    if (!i) return;
    const s = (b) => {
      switch (b) {
        case w.Disconnected:
          R && R();
          break;
        case w.Connected:
          E && E();
          break;
      }
    };
    return i.on(d.ConnectionStateChanged, s), () => {
      i.off(d.ConnectionStateChanged, s);
    };
  }, [e, E, R, i]), a.useEffect(() => {
    if (i)
      return () => {
        u.info("disconnecting on onmount"), i.disconnect();
      };
  }, [i]), { room: i, htmlProps: A };
}
const z = /* @__PURE__ */ a.forwardRef(function(e, o) {
  const { room: t, htmlProps: r } = T(e);
  return /* @__PURE__ */ a.createElement("div", { ref: o, ...r }, t && /* @__PURE__ */ a.createElement(K.Provider, { value: t }, /* @__PURE__ */ a.createElement(M.Provider, { value: e.featureFlags }, e.children)));
});
export {
  z as L,
  j as c,
  U as m,
  T as u
};
//# sourceMappingURL=room-9If4zpLS.mjs.map
