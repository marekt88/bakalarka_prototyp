{"version":3,"file":"shared-Dm0MXW3h.js","sources":["../src/hooks/useAudioPlayback.ts","../src/hooks/useClearPinButton.ts","../src/hooks/useDataChannel.ts","../src/hooks/useLiveKitRoom.ts","../src/hooks/useParticipantInfo.ts","../src/hooks/useParticipantPermissions.ts","../src/hooks/useRemoteParticipants.ts","../src/hooks/useParticipants.ts","../src/hooks/useRemoteParticipant.ts","../src/hooks/useRoomInfo.ts","../src/hooks/useSpeakingParticipants.ts","../src/hooks/useSortedParticipants.ts","../src/hooks/useToken.ts","../src/hooks/useTrackRefBySourceOrName.ts","../src/hooks/useTrackByName.ts","../src/hooks/useParticipantTracks.ts","../src/hooks/useTrackSyncTime.ts","../src/hooks/useTrackTranscription.ts","../src/hooks/useParticipantAttributes.ts","../src/hooks/useVoiceAssistant.ts","../src/hooks/useIsRecording.ts"],"sourcesContent":["import type { Room } from 'livekit-client';\nimport * as React from 'react';\nimport { useObservableState } from './internal';\nimport { roomAudioPlaybackAllowedObservable } from '@livekit/components-core';\nimport { useEnsureRoom } from '../context';\n\n/**\n * In many browsers to start audio playback, the user must perform a user-initiated event such as clicking a button.\n * The `useAudioPlayback` hook returns an object with a boolean `canPlayAudio` flag that indicates whether audio\n * playback is allowed in the current context, as well as a `startAudio` function that can be called in a button\n * `onClick` callback to start audio playback in the current context.\n *\n * @see Autoplay policy on MDN web docs for more info: {@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API/Best_practices#autoplay_policy}\n * @alpha\n */\nexport function useAudioPlayback(room?: Room): {\n  canPlayAudio: boolean;\n  startAudio: () => Promise<void>;\n} {\n  const roomEnsured = useEnsureRoom(room);\n  const startAudio = React.useCallback(async () => {\n    await roomEnsured.startAudio();\n  }, [roomEnsured]);\n\n  const observable = React.useMemo(\n    () => roomAudioPlaybackAllowedObservable(roomEnsured),\n    [roomEnsured],\n  );\n  const { canPlayAudio } = useObservableState(observable, {\n    canPlayAudio: roomEnsured.canPlaybackAudio,\n  });\n\n  return { canPlayAudio, startAudio };\n}\n","import { setupClearPinButton } from '@livekit/components-core';\nimport * as React from 'react';\nimport { useLayoutContext } from '../context';\nimport { mergeProps } from '../mergeProps';\nimport type { ClearPinButtonProps } from '../components';\n\n/**\n * The `useClearPinButton` hook provides props for the {@link ClearPinButton}\n * or your custom implementation of it component. It adds the `onClick` handler\n * to signal the `LayoutContext` that the tile in focus should be cleared.\n * @public\n */\nexport function useClearPinButton(props: ClearPinButtonProps) {\n  const { state, dispatch } = useLayoutContext().pin;\n\n  const buttonProps = React.useMemo(() => {\n    const { className } = setupClearPinButton();\n    const mergedProps = mergeProps(props, {\n      className,\n      disabled: !state?.length,\n      onClick: () => {\n        if (dispatch) dispatch({ msg: 'clear_pin' });\n      },\n    });\n    return mergedProps;\n  }, [props, dispatch, state]);\n\n  return { buttonProps };\n}\n","import type { ReceivedDataMessage } from '@livekit/components-core';\nimport { setupDataMessageHandler } from '@livekit/components-core';\nimport * as React from 'react';\nimport type { DataPublishOptions } from 'livekit-client';\nimport { useRoomContext } from '../context';\nimport { useObservableState } from './internal';\n\ntype UseDataChannelReturnType<T extends string | undefined = undefined> = {\n  isSending: boolean;\n  send: (payload: Uint8Array, options: DataPublishOptions) => void;\n  message: ReceivedDataMessage<T> | undefined;\n};\n\n/**\n * The `useDataChannel` hook returns the ability to send and receive messages.\n * By optionally passing a `topic`, you can narrow down which messages are returned in the messages array.\n * @remarks\n * There is only one data channel. Passing a `topic` does not open a new data channel.\n * It is only used to filter out messages with no or a different `topic`.\n *\n * @example\n * ```tsx\n * // Send messages to all participants via the 'chat' topic.\n * const { message: latestMessage, send } = useDataChannel('chat', (msg) => console.log(\"message received\", msg));\n * ```\n * @public\n */\nexport function useDataChannel<T extends string>(\n  topic: T,\n  onMessage?: (msg: ReceivedDataMessage<T>) => void,\n): UseDataChannelReturnType<T>;\n/**\n * The `useDataChannel` hook returns the ability to send and receive messages.\n * @remarks\n * There is only one data channel. Passing a `topic` does not open a new data channel.\n * It is only used to filter out messages with no or a different `topic`.\n *\n * @example\n * ```tsx\n * // Send messages to all participants\n * const { message: latestMessage, send } = useDataChannel('chat', (msg) => console.log(\"message received\", msg));\n * ```\n * @public\n */\nexport function useDataChannel(\n  onMessage?: (msg: ReceivedDataMessage) => void,\n): UseDataChannelReturnType;\n/**\n * @internal\n */\nexport function useDataChannel<T extends string>(\n  topicOrCallback?: T | ((msg: ReceivedDataMessage) => void),\n  callback?: (msg: ReceivedDataMessage<T>) => void,\n) {\n  const onMessage = typeof topicOrCallback === 'function' ? topicOrCallback : callback;\n\n  const topic = typeof topicOrCallback === 'string' ? topicOrCallback : undefined;\n  const room = useRoomContext();\n  const { send, messageObservable, isSendingObservable } = React.useMemo(\n    () => setupDataMessageHandler(room, topic, onMessage),\n    [room, topic, onMessage],\n  );\n\n  const message = useObservableState(messageObservable, undefined);\n  const isSending = useObservableState(isSendingObservable, false);\n\n  return {\n    message,\n    send,\n    isSending,\n  };\n}\n","import { log, setupLiveKitRoom } from '@livekit/components-core';\nimport { Room, MediaDeviceFailure, RoomEvent, ConnectionState } from 'livekit-client';\nimport * as React from 'react';\nimport type { HTMLAttributes } from 'react';\n\nimport type { LiveKitRoomProps } from '../components';\nimport { mergeProps } from '../mergeProps';\n\nconst defaultRoomProps: Partial<LiveKitRoomProps> = {\n  connect: true,\n  audio: false,\n  video: false,\n};\n\n/**\n * The `useLiveKitRoom` hook is used to implement the `LiveKitRoom` or your custom implementation of it.\n * It returns a `Room` instance and HTML props that should be applied to the root element of the component.\n *\n * @example\n * ```tsx\n * const { room, htmlProps } = useLiveKitRoom();\n * return <div {...htmlProps}>...</div>;\n * ```\n * @public\n */\nexport function useLiveKitRoom<T extends HTMLElement>(\n  props: LiveKitRoomProps,\n): {\n  room: Room | undefined;\n  htmlProps: HTMLAttributes<T>;\n} {\n  const {\n    token,\n    serverUrl,\n    options,\n    room: passedRoom,\n    connectOptions,\n    connect,\n    audio,\n    video,\n    screen,\n    onConnected,\n    onDisconnected,\n    onError,\n    onMediaDeviceFailure,\n    onEncryptionError,\n    simulateParticipants,\n    ...rest\n  } = { ...defaultRoomProps, ...props };\n  if (options && passedRoom) {\n    log.warn(\n      'when using a manually created room, the options object will be ignored. set the desired options directly when creating the room instead.',\n    );\n  }\n\n  const [room, setRoom] = React.useState<Room | undefined>();\n\n  React.useEffect(() => {\n    setRoom(passedRoom ?? new Room(options));\n  }, [passedRoom]);\n\n  const htmlProps = React.useMemo(() => {\n    const { className } = setupLiveKitRoom();\n    return mergeProps(rest, { className }) as HTMLAttributes<T>;\n  }, [rest]);\n\n  React.useEffect(() => {\n    if (!room) return;\n    const onSignalConnected = () => {\n      const localP = room.localParticipant;\n\n      log.debug('trying to publish local tracks');\n      Promise.all([\n        localP.setMicrophoneEnabled(!!audio, typeof audio !== 'boolean' ? audio : undefined),\n        localP.setCameraEnabled(!!video, typeof video !== 'boolean' ? video : undefined),\n        localP.setScreenShareEnabled(!!screen, typeof screen !== 'boolean' ? screen : undefined),\n      ]).catch((e) => {\n        log.warn(e);\n        onError?.(e as Error);\n      });\n    };\n\n    const handleMediaDeviceError = (e: Error) => {\n      const mediaDeviceFailure = MediaDeviceFailure.getFailure(e);\n      onMediaDeviceFailure?.(mediaDeviceFailure);\n    };\n    const handleEncryptionError = (e: Error) => {\n      onEncryptionError?.(e);\n    };\n    room\n      .on(RoomEvent.SignalConnected, onSignalConnected)\n      .on(RoomEvent.MediaDevicesError, handleMediaDeviceError)\n      .on(RoomEvent.EncryptionError, handleEncryptionError);\n\n    return () => {\n      room\n        .off(RoomEvent.SignalConnected, onSignalConnected)\n        .off(RoomEvent.MediaDevicesError, handleMediaDeviceError)\n        .off(RoomEvent.EncryptionError, handleEncryptionError);\n    };\n  }, [room, audio, video, screen, onError, onEncryptionError, onMediaDeviceFailure]);\n\n  React.useEffect(() => {\n    if (!room) return;\n\n    if (simulateParticipants) {\n      room.simulateParticipants({\n        participants: {\n          count: simulateParticipants,\n        },\n        publish: {\n          audio: true,\n          useRealTracks: true,\n        },\n      });\n      return;\n    }\n    if (!token) {\n      log.debug('no token yet');\n      return;\n    }\n    if (!serverUrl) {\n      log.warn('no livekit url provided');\n      onError?.(Error('no livekit url provided'));\n      return;\n    }\n    if (connect) {\n      log.debug('connecting');\n      room.connect(serverUrl, token, connectOptions).catch((e) => {\n        log.warn(e);\n        onError?.(e as Error);\n      });\n    } else {\n      log.debug('disconnecting because connect is false');\n      room.disconnect();\n    }\n  }, [\n    connect,\n    token,\n    JSON.stringify(connectOptions),\n    room,\n    onError,\n    serverUrl,\n    simulateParticipants,\n  ]);\n\n  React.useEffect(() => {\n    if (!room) return;\n    const connectionStateChangeListener = (state: ConnectionState) => {\n      switch (state) {\n        case ConnectionState.Disconnected:\n          if (onDisconnected) onDisconnected();\n          break;\n        case ConnectionState.Connected:\n          if (onConnected) onConnected();\n          break;\n\n        default:\n          break;\n      }\n    };\n    room.on(RoomEvent.ConnectionStateChanged, connectionStateChangeListener);\n    return () => {\n      room.off(RoomEvent.ConnectionStateChanged, connectionStateChangeListener);\n    };\n  }, [token, onConnected, onDisconnected, room]);\n\n  React.useEffect(() => {\n    if (!room) return;\n    return () => {\n      log.info('disconnecting on onmount');\n      room.disconnect();\n    };\n  }, [room]);\n\n  return { room, htmlProps };\n}\n","import { participantInfoObserver } from '@livekit/components-core';\nimport type { Participant } from 'livekit-client';\nimport * as React from 'react';\nimport { useMaybeParticipantContext } from '../context';\nimport { useObservableState } from './internal';\n\n/**\n * The `useParticipantInfo` hook returns the identity, name, and metadata of a given participant.\n * It requires a `Participant` object passed as property or via the `ParticipantContext`.\n *\n * @example\n * ```tsx\n * const { identity, name, metadata } = useParticipantInfo({ participant });\n * ```\n * @public\n */\nexport interface UseParticipantInfoOptions {\n  participant?: Participant;\n}\n\n/** @public */\nexport function useParticipantInfo(props: UseParticipantInfoOptions = {}) {\n  let p = useMaybeParticipantContext();\n  if (props.participant) {\n    p = props.participant;\n  }\n  const infoObserver = React.useMemo(() => participantInfoObserver(p), [p]);\n  const { identity, name, metadata } = useObservableState(infoObserver, {\n    name: p?.name,\n    identity: p?.identity,\n    metadata: p?.metadata,\n  });\n\n  return { identity, name, metadata };\n}\n","import { participantPermissionObserver } from '@livekit/components-core';\nimport type { ParticipantPermission } from '@livekit/protocol';\nimport type { Participant } from 'livekit-client';\nimport * as React from 'react';\nimport { useEnsureParticipant } from '../context';\nimport { useObservableState } from './internal/useObservableState';\n\n/**\n * The `useParticipantPermissions` hook returns the permissions of a given participant.\n *\n * @example\n * ```tsx\n * const permissions = useParticipantPermissions({ participant });\n * ```\n * @public\n */\nexport interface UseParticipantPermissionsOptions {\n  participant?: Participant;\n}\n\n/** @public */\nexport function useParticipantPermissions(\n  options: UseParticipantPermissionsOptions = {},\n): ParticipantPermission | undefined {\n  const p = useEnsureParticipant(options.participant);\n  const permissionObserver = React.useMemo(() => participantPermissionObserver(p), [p]);\n  const permissions = useObservableState(permissionObserver, p.permissions);\n  return permissions;\n}\n","import { connectedParticipantsObserver } from '@livekit/components-core';\nimport type { RoomEvent, RemoteParticipant, Room } from 'livekit-client';\nimport * as React from 'react';\nimport { useEnsureRoom } from '../context';\n\n/** @public */\nexport interface UseRemoteParticipantsOptions {\n  /**\n   * To optimize performance, you can use the `updateOnlyOn` property to decide on what RoomEvents the hook updates.\n   * By default it updates on all relevant RoomEvents to keep the returned participants array up to date.\n   * The minimal set of non-overwriteable `RoomEvents` is: `[RoomEvent.ParticipantConnected, RoomEvent.ParticipantDisconnected, RoomEvent.ConnectionStateChanged]`\n   */\n  updateOnlyOn?: RoomEvent[];\n  /**\n   * The room to use. If not provided, the hook will use the room from the context.\n   */\n  room?: Room;\n}\n\n/**\n * The `useRemoteParticipants` hook returns all remote participants (without the local) of the current room.\n * @remarks\n * To optimize performance, you can use the `updateOnlyOn` property to decide on what `RoomEvents` the hook updates.\n *\n * @example\n * ```tsx\n * const participants = useRemoteParticipants();\n * <ParticipantLoop participants={participants}>\n *  <ParticipantName />\n * </ParticipantLoop>\n * ```\n * @public\n */\nexport function useRemoteParticipants(options: UseRemoteParticipantsOptions = {}) {\n  const room = useEnsureRoom(options.room);\n  const [participants, setParticipants] = React.useState<RemoteParticipant[]>([]);\n\n  React.useEffect(() => {\n    const listener = connectedParticipantsObserver(room, {\n      additionalRoomEvents: options.updateOnlyOn,\n    }).subscribe(setParticipants);\n    return () => listener.unsubscribe();\n  }, [room, JSON.stringify(options.updateOnlyOn)]);\n  return participants;\n}\n","import type { Room, RoomEvent } from 'livekit-client';\nimport { useLocalParticipant } from './useLocalParticipant';\nimport { useRemoteParticipants } from './useRemoteParticipants';\nimport * as React from 'react';\n\n/** @public */\nexport interface UseParticipantsOptions {\n  /**\n   * To optimize performance, you can use the `updateOnlyOn` property to decide on what RoomEvents the hook updates.\n   * By default it updates on all relevant RoomEvents to keep the returned participants array up to date.\n   * The minimal set of non-overwriteable `RoomEvents` is: `[RoomEvent.ParticipantConnected, RoomEvent.ParticipantDisconnected, RoomEvent.ConnectionStateChanged]`\n   */\n  updateOnlyOn?: RoomEvent[];\n  /**\n   * The room to use. If not provided, the hook will use the room from the context.\n   */\n  room?: Room;\n}\n\n/**\n * The `useParticipants` hook returns all participants (local and remote) of the current room.\n * @remarks\n * To optimize performance, you can use the `updateOnlyOn` property to decide on what `RoomEvents` the hook updates.\n *\n * @example\n * ```tsx\n * const participants = useParticipants();\n * <ParticipantLoop participants={participants}>\n *  <ParticipantName />\n * </ParticipantLoop>\n * ```\n * @public\n */\nexport function useParticipants(options: UseParticipantsOptions = {}) {\n  const remoteParticipants = useRemoteParticipants(options);\n  const { localParticipant } = useLocalParticipant(options);\n\n  return React.useMemo(\n    () => [localParticipant, ...remoteParticipants],\n    [localParticipant, remoteParticipants],\n  );\n}\n","import {\n  type ParticipantIdentifier,\n  connectedParticipantObserver,\n  participantByIdentifierObserver,\n} from '@livekit/components-core';\nimport type { ParticipantEvent, RemoteParticipant } from 'livekit-client';\nimport * as React from 'react';\nimport { useRoomContext } from '../context';\n\n/** @public */\nexport interface UseRemoteParticipantOptions {\n  /**\n   * To optimize performance, you can use the `updateOnlyOn` property to decide on what `ParticipantEvents` the hook updates.\n   * By default it updates on all relevant ParticipantEvents to keep the returned participant up to date.\n   */\n  updateOnlyOn?: ParticipantEvent[];\n}\n\n/**\n * The `useRemoteParticipant` hook returns the first RemoteParticipant by either identity and/or based on the participant kind.\n * @remarks\n * To optimize performance, you can use the `updateOnlyOn` property to decide on what `ParticipantEvents` the hook updates.\n *\n * @example\n * ```tsx\n * const participant = useRemoteParticipant({kind: ParticipantKind.Agent, identity: 'myAgent'});\n * ```\n * @public\n */\nexport function useRemoteParticipant(\n  identifier: ParticipantIdentifier,\n  options?: UseRemoteParticipantOptions,\n): RemoteParticipant | undefined;\n/**\n * The `useRemoteParticipant` hook returns the first RemoteParticipant by either identity or based on the participant kind.\n * @remarks\n * To optimize performance, you can use the `updateOnlyOn` property to decide on what `ParticipantEvents` the hook updates.\n *\n * @example\n * ```tsx\n * const participant = useRemoteParticipant('Russ');\n * ```\n * @public\n */\nexport function useRemoteParticipant(\n  identity: string,\n  options?: UseRemoteParticipantOptions,\n): RemoteParticipant | undefined;\nexport function useRemoteParticipant(\n  identityOrIdentifier: string | ParticipantIdentifier,\n  options: UseRemoteParticipantOptions = {},\n): RemoteParticipant | undefined {\n  const room = useRoomContext();\n  const [updateOnlyOn] = React.useState(options.updateOnlyOn);\n\n  const observable = React.useMemo(() => {\n    if (typeof identityOrIdentifier === 'string') {\n      return connectedParticipantObserver(room, identityOrIdentifier, {\n        additionalEvents: updateOnlyOn,\n      });\n    } else {\n      return participantByIdentifierObserver(room, identityOrIdentifier, {\n        additionalEvents: updateOnlyOn,\n      });\n    }\n  }, [room, JSON.stringify(identityOrIdentifier), updateOnlyOn]);\n\n  // Using `wrapperParticipant` to ensure a new object reference,\n  // triggering a re-render when the participant events fire.\n  const [participantWrapper, setParticipantWrapper] = React.useState({\n    p: undefined as RemoteParticipant | undefined,\n  });\n  React.useEffect(() => {\n    const listener = observable.subscribe((p) => setParticipantWrapper({ p }));\n    return () => listener.unsubscribe();\n  }, [observable]);\n\n  return participantWrapper.p;\n}\n","import { roomInfoObserver } from '@livekit/components-core';\nimport type { Room } from 'livekit-client';\nimport * as React from 'react';\nimport { useEnsureRoom } from '../context';\nimport { useObservableState } from './internal';\n\n/**\n * The `useRoomInfo` hook returns the name and metadata of the given `Room`.\n * @remarks\n * Needs to be called inside a `RoomContext` or by passing a `Room` instance.\n *\n * @example\n * ```tsx\n * const { name, metadata } = useRoomInfo();\n * ```\n * @public\n */\nexport interface UseRoomInfoOptions {\n  room?: Room;\n}\n\n/** @public */\nexport function useRoomInfo(options: UseRoomInfoOptions = {}) {\n  const room = useEnsureRoom(options.room);\n  const infoObserver = React.useMemo(() => roomInfoObserver(room), [room]);\n  const { name, metadata } = useObservableState(infoObserver, {\n    name: room.name,\n    metadata: room.metadata,\n  });\n\n  return { name, metadata };\n}\n","import { activeSpeakerObserver } from '@livekit/components-core';\nimport * as React from 'react';\nimport { useRoomContext } from '../context';\nimport { useObservableState } from './internal';\n\n/**\n * The `useSpeakingParticipants` hook returns the only the active speakers of all participants.\n *\n * @example\n * ```tsx\n * const activeSpeakers = useSpeakingParticipants();\n * ```\n * @public\n */\nexport function useSpeakingParticipants() {\n  const room = useRoomContext();\n  const speakerObserver = React.useMemo(() => activeSpeakerObserver(room), [room]);\n  const activeSpeakers = useObservableState(speakerObserver, room.activeSpeakers);\n  return activeSpeakers;\n}\n","import { sortParticipants } from '@livekit/components-core';\nimport type { Participant } from 'livekit-client';\nimport * as React from 'react';\nimport { useSpeakingParticipants } from './useSpeakingParticipants';\n\n/**\n * The `useSortedParticipants` hook returns the participants sorted by importance.\n * @public\n */\nexport function useSortedParticipants(participants: Array<Participant>) {\n  const [sortedParticipants, setSortedParticipants] = React.useState(\n    sortParticipants(participants),\n  );\n  const activeSpeakers = useSpeakingParticipants();\n\n  React.useEffect(() => {\n    setSortedParticipants(sortParticipants(participants));\n  }, [activeSpeakers, participants]);\n  return sortedParticipants;\n}\n","import { log } from '@livekit/components-core';\nimport * as React from 'react';\n\n/** @public */\nexport interface UserInfo {\n  identity?: string;\n  name?: string;\n  metadata?: string;\n}\n\n/** @public */\nexport interface UseTokenOptions {\n  userInfo?: UserInfo;\n}\n\n/**\n * The `useToken` hook fetches a token from the given token endpoint with the given user info.\n *\n * @example\n * ```tsx\n * const token = useToken(<token-endpoint>, roomName, { userInfo: { identity, name }});\n * ```\n * @public */\nexport function useToken(\n  tokenEndpoint: string | undefined,\n  roomName: string,\n  options: UseTokenOptions = {},\n) {\n  const [token, setToken] = React.useState<string | undefined>(undefined);\n\n  React.useEffect(() => {\n    if (tokenEndpoint === undefined) {\n      throw Error('token endpoint needs to be defined');\n    }\n    if (options.userInfo?.identity === undefined) {\n      return;\n    }\n    const tokenFetcher = async () => {\n      log.debug('fetching token');\n      const params = new URLSearchParams({ ...options.userInfo, roomName });\n      const res = await fetch(`${tokenEndpoint}?${params.toString()}`);\n      if (!res.ok) {\n        log.error(\n          `Could not fetch token. Server responded with status ${res.status}: ${res.statusText}`,\n        );\n        return;\n      }\n      const { accessToken } = await res.json();\n      setToken(accessToken);\n    };\n    tokenFetcher();\n  }, [tokenEndpoint, roomName, JSON.stringify(options)]);\n  return token;\n}\n","import type { TrackReferenceOrPlaceholder, TrackSource } from '@livekit/components-core';\nimport { setupMediaTrack, getTrackByIdentifier } from '@livekit/components-core';\nimport * as React from 'react';\nimport { Track } from 'livekit-client';\n\n/**\n * @internal\n */\nexport function useTrackRefBySourceOrName(\n  source: TrackSource<Track.Source>,\n): TrackReferenceOrPlaceholder {\n  const [publication, setPublication] = React.useState(getTrackByIdentifier(source));\n\n  const { trackObserver } = React.useMemo(() => {\n    return setupMediaTrack(source);\n  }, [source.participant.sid ?? source.participant.identity, source.source]);\n\n  React.useEffect(() => {\n    const subscription = trackObserver.subscribe((publication) => {\n      setPublication(publication);\n    });\n    return () => subscription?.unsubscribe();\n  }, [trackObserver]);\n\n  return {\n    participant: source.participant,\n    source: source.source ?? Track.Source.Unknown,\n    publication,\n  };\n}\n","import type { Participant } from 'livekit-client';\nimport { useEnsureParticipant } from '../context';\nimport { useTrackRefBySourceOrName } from './useTrackRefBySourceOrName';\n\n/**\n * This function `useTrackByName` allows you to access a track by referencing its track name.\n * Inside the function, it ensures that the a valid `participant` reference is available by checking\n * for both a passed participant argument and, if not available, a valid participant context.\n *\n * @public\n */\nexport function useTrackByName(name: string, participant?: Participant) {\n  const p = useEnsureParticipant(participant);\n  return useTrackRefBySourceOrName({ name, participant: p });\n}\n","import * as React from 'react';\nimport type { TrackReference } from '@livekit/components-core';\nimport { participantTracksObservable } from '@livekit/components-core';\nimport { useObservableState } from './internal';\nimport type { Track } from 'livekit-client';\nimport { useMaybeParticipantContext, useRoomContext } from '../context';\n\n/**\n * `useParticipantTracks` is a custom React that allows you to get tracks of a specific participant only, by specifiying the participant's identity.\n * If the participant identity is not passed the hook will try to get the participant from a participant context.\n * @public\n */\nexport function useParticipantTracks(\n  sources: Track.Source[],\n  participantIdentity?: string,\n): TrackReference[] {\n  const room = useRoomContext();\n  const participantContext = useMaybeParticipantContext();\n  const p = participantIdentity\n    ? room.getParticipantByIdentity(participantIdentity)\n    : participantContext;\n  const observable = React.useMemo(\n    () => (p ? participantTracksObservable(p, { sources }) : undefined),\n    [p?.sid, p?.identity, JSON.stringify(sources)],\n  );\n\n  const trackRefs = useObservableState(observable, [] as TrackReference[]);\n\n  return trackRefs;\n}\n","import * as React from 'react';\nimport { type TrackReferenceOrPlaceholder, trackSyncTimeObserver } from '@livekit/components-core';\nimport { useObservableState } from './internal';\n\n/**\n * @internal\n */\nexport function useTrackSyncTime(ref: TrackReferenceOrPlaceholder | undefined) {\n  const observable = React.useMemo(\n    () => (ref?.publication?.track ? trackSyncTimeObserver(ref?.publication.track) : undefined),\n    [ref?.publication?.track],\n  );\n  return useObservableState(observable, {\n    timestamp: Date.now(),\n    rtpTimestamp: ref?.publication?.track?.rtpTimestamp,\n  });\n}\n","import {\n  type ReceivedTranscriptionSegment,\n  addMediaTimestampToTranscription as addTimestampsToTranscription,\n  dedupeSegments,\n  // getActiveTranscriptionSegments,\n  getTrackReferenceId,\n  trackTranscriptionObserver,\n  type TrackReferenceOrPlaceholder,\n  // didActiveSegmentsChange,\n} from '@livekit/components-core';\nimport type { TranscriptionSegment } from 'livekit-client';\nimport * as React from 'react';\nimport { useTrackSyncTime } from './useTrackSyncTime';\n\n/**\n * @alpha\n */\nexport interface TrackTranscriptionOptions {\n  /**\n   * how many transcription segments should be buffered in state\n   * @defaultValue 100\n   */\n  bufferSize?: number;\n  /**\n   * optional callback for retrieving newly incoming transcriptions only\n   */\n  onTranscription?: (newSegments: TranscriptionSegment[]) => void;\n  /** amount of time (in ms) that the segment is considered `active` past its original segment duration, defaults to 2_000 */\n  // maxAge?: number;\n}\n\nconst TRACK_TRANSCRIPTION_DEFAULTS = {\n  bufferSize: 100,\n  // maxAge: 2_000,\n} as const satisfies TrackTranscriptionOptions;\n\n/**\n * @returns An object consisting of `segments` with maximum length of opts.windowLength and `activeSegments` that are valid for the current track timestamp\n * @alpha\n */\nexport function useTrackTranscription(\n  trackRef: TrackReferenceOrPlaceholder | undefined,\n  options?: TrackTranscriptionOptions,\n) {\n  const opts = { ...TRACK_TRANSCRIPTION_DEFAULTS, ...options };\n  const [segments, setSegments] = React.useState<Array<ReceivedTranscriptionSegment>>([]);\n  // const [activeSegments, setActiveSegments] = React.useState<Array<ReceivedTranscriptionSegment>>(\n  //   [],\n  // );\n  // const prevActiveSegments = React.useRef<ReceivedTranscriptionSegment[]>([]);\n  const syncTimestamps = useTrackSyncTime(trackRef);\n  const handleSegmentMessage = (newSegments: TranscriptionSegment[]) => {\n    opts.onTranscription?.(newSegments);\n    setSegments((prevSegments) =>\n      dedupeSegments(\n        prevSegments,\n        // when first receiving a segment, add the current media timestamp to it\n        newSegments.map((s) => addTimestampsToTranscription(s, syncTimestamps)),\n        opts.bufferSize,\n      ),\n    );\n  };\n  React.useEffect(() => {\n    if (!trackRef?.publication) {\n      return;\n    }\n    const subscription = trackTranscriptionObserver(trackRef.publication).subscribe((evt) => {\n      handleSegmentMessage(...evt);\n    });\n    return () => {\n      subscription.unsubscribe();\n    };\n  }, [trackRef && getTrackReferenceId(trackRef), handleSegmentMessage]);\n\n  // React.useEffect(() => {\n  //   if (syncTimestamps) {\n  //     const newActiveSegments = getActiveTranscriptionSegments(\n  //       segments,\n  //       syncTimestamps,\n  //       opts.maxAge,\n  //     );\n  //     // only update active segment array if content actually changed\n  //     if (didActiveSegmentsChange(prevActiveSegments.current, newActiveSegments)) {\n  //       setActiveSegments(newActiveSegments);\n  //       prevActiveSegments.current = newActiveSegments;\n  //     }\n  //   }\n  // }, [syncTimestamps, segments, opts.maxAge]);\n\n  return { segments };\n}\n","import { participantAttributesObserver } from '@livekit/components-core';\nimport type { Participant } from 'livekit-client';\nimport * as React from 'react';\nimport { useEnsureParticipant, useMaybeParticipantContext } from '../context';\nimport { useObservableState } from './internal';\n\n/**\n * The `useParticipantAttributes` hook returns the attributes of a given participant and allows to set them.\n * It requires a `Participant` object passed as property or via the `ParticipantContext`.\n *\n * @example\n * ```tsx\n * const { attributes } = useParticipantAttributes({ participant });\n * ```\n * @public\n */\nexport interface UseParticipantAttributesOptions {\n  participant?: Participant;\n}\n\n/** @public */\nexport function useParticipantAttributes(props: UseParticipantAttributesOptions = {}) {\n  const participantContext = useMaybeParticipantContext();\n  const p = props.participant ?? participantContext;\n  const attributeObserver = React.useMemo(\n    // weird typescript constraint\n    () => (p ? participantAttributesObserver(p) : participantAttributesObserver(p)),\n    [p],\n  );\n  const attributeState = useObservableState(attributeObserver, {\n    attributes: p?.attributes,\n  });\n\n  return attributeState;\n}\n\n/**\n * The `useParticipantAttribute` hook returns the latest value of a given attribute key of a participant.\n * It requires a `Participant` object passed as property in the `UseParticipantAttributesOptions` or via the `ParticipantContext`.\n *\n * @example\n * ```tsx\n * const myAttributeValue = useParticipantAttribute('targetAttributeName');\n * ```\n * @public\n */\nexport function useParticipantAttribute(\n  attributeKey: string,\n  options: UseParticipantAttributesOptions = {},\n) {\n  const p = useEnsureParticipant(options.participant);\n  const [attribute, setAttribute] = React.useState(p.attributes[attributeKey]);\n\n  React.useEffect(() => {\n    if (!p) {\n      return;\n    }\n    const subscription = participantAttributesObserver(p).subscribe((val) => {\n      if (val.changed[attributeKey] !== undefined) {\n        setAttribute(val.attributes[attributeKey]);\n      }\n    });\n    return () => {\n      subscription.unsubscribe();\n    };\n  }, [p, attributeKey]);\n\n  return attribute;\n}\n","import * as React from 'react';\nimport { ConnectionState, ParticipantKind, Track } from 'livekit-client';\nimport type { RemoteParticipant } from 'livekit-client';\nimport type { ReceivedTranscriptionSegment, TrackReference } from '@livekit/components-core';\nimport { useRemoteParticipants } from './useRemoteParticipants';\nimport { useParticipantTracks } from './useParticipantTracks';\nimport { useTrackTranscription } from './useTrackTranscription';\nimport { useConnectionState } from './useConnectionStatus';\nimport { useParticipantAttributes } from './useParticipantAttributes';\n\n/**\n * @beta\n */\nexport type AgentState =\n  | 'disconnected'\n  | 'connecting'\n  | 'initializing'\n  | 'listening'\n  | 'thinking'\n  | 'speaking';\n\n/**\n * @beta\n */\nexport interface VoiceAssistant {\n  agent: RemoteParticipant | undefined;\n  state: AgentState;\n  audioTrack: TrackReference | undefined;\n  agentTranscriptions: ReceivedTranscriptionSegment[];\n  agentAttributes: RemoteParticipant['attributes'] | undefined;\n}\n\nconst state_attribute = 'lk.agent.state';\n\n/**\n * This hook looks for the first agent-participant in the room.\n * @remarks This hook requires an agent running with livekit-agents \\>= 0.9.0\n * @example\n * ```tsx\n * const { state, audioTrack, agentTranscriptions, agentAttributes } = useVoiceAssistant();\n * ```\n * @beta\n */\nexport function useVoiceAssistant(): VoiceAssistant {\n  const agent = useRemoteParticipants().find((p) => p.kind === ParticipantKind.AGENT);\n  const audioTrack = useParticipantTracks([Track.Source.Microphone], agent?.identity)[0];\n  const { segments: agentTranscriptions } = useTrackTranscription(audioTrack);\n  const connectionState = useConnectionState();\n  const { attributes } = useParticipantAttributes({ participant: agent });\n\n  const state: AgentState = React.useMemo(() => {\n    if (connectionState === ConnectionState.Disconnected) {\n      return 'disconnected';\n    } else if (\n      connectionState === ConnectionState.Connecting ||\n      !agent ||\n      !attributes?.[state_attribute]\n    ) {\n      return 'connecting';\n    } else {\n      return attributes[state_attribute] as AgentState;\n    }\n  }, [attributes, agent, connectionState]);\n\n  return {\n    agent,\n    state,\n    audioTrack,\n    agentTranscriptions,\n    agentAttributes: attributes,\n  };\n}\n","import { recordingStatusObservable } from '@livekit/components-core';\nimport * as React from 'react';\nimport { useEnsureRoom } from '../context';\nimport { useObservableState } from './internal';\nimport { useConnectionState } from './useConnectionStatus';\nimport type { Room } from 'livekit-client';\n\n/**\n * The `useIsRecording` hook returns a `boolean` that indicates if the room is currently being recorded.\n * @example\n * ```tsx\n * const isRecording = useIsRecording();\n * ```\n * @public\n */\nexport function useIsRecording(room?: Room) {\n  const r = useEnsureRoom(room);\n  const connectionState = useConnectionState(r);\n  const observable = React.useMemo(() => recordingStatusObservable(r), [r, connectionState]);\n  const isRecording = useObservableState(observable, r.isRecording);\n\n  return isRecording;\n}\n"],"names":["useAudioPlayback","room","roomEnsured","useEnsureRoom","startAudio","React","observable","roomAudioPlaybackAllowedObservable","canPlayAudio","useObservableState","useClearPinButton","props","state","dispatch","useLayoutContext","className","setupClearPinButton","mergeProps","useDataChannel","topicOrCallback","callback","onMessage","topic","useRoomContext","send","messageObservable","isSendingObservable","setupDataMessageHandler","message","isSending","defaultRoomProps","useLiveKitRoom","token","serverUrl","options","passedRoom","connectOptions","connect","audio","video","screen","onConnected","onDisconnected","onError","onMediaDeviceFailure","onEncryptionError","simulateParticipants","rest","log","setRoom","Room","htmlProps","setupLiveKitRoom","onSignalConnected","localP","e","handleMediaDeviceError","mediaDeviceFailure","MediaDeviceFailure","handleEncryptionError","RoomEvent","connectionStateChangeListener","ConnectionState","useParticipantInfo","p","useMaybeParticipantContext","infoObserver","participantInfoObserver","identity","name","metadata","useParticipantPermissions","useEnsureParticipant","permissionObserver","participantPermissionObserver","useRemoteParticipants","participants","setParticipants","listener","connectedParticipantsObserver","useParticipants","remoteParticipants","localParticipant","useLocalParticipant","useRemoteParticipant","identityOrIdentifier","updateOnlyOn","connectedParticipantObserver","participantByIdentifierObserver","participantWrapper","setParticipantWrapper","useRoomInfo","roomInfoObserver","useSpeakingParticipants","speakerObserver","activeSpeakerObserver","useSortedParticipants","sortedParticipants","setSortedParticipants","sortParticipants","activeSpeakers","useToken","tokenEndpoint","roomName","setToken","_a","params","res","accessToken","useTrackRefBySourceOrName","source","publication","setPublication","getTrackByIdentifier","trackObserver","setupMediaTrack","subscription","Track","useTrackByName","participant","useParticipantTracks","sources","participantIdentity","participantContext","participantTracksObservable","useTrackSyncTime","ref","trackSyncTimeObserver","_c","_b","TRACK_TRANSCRIPTION_DEFAULTS","useTrackTranscription","trackRef","opts","segments","setSegments","syncTimestamps","handleSegmentMessage","newSegments","prevSegments","dedupeSegments","s","addTimestampsToTranscription","trackTranscriptionObserver","evt","getTrackReferenceId","useParticipantAttributes","attributeObserver","participantAttributesObserver","useParticipantAttribute","attributeKey","attribute","setAttribute","val","state_attribute","useVoiceAssistant","agent","ParticipantKind","audioTrack","agentTranscriptions","connectionState","useConnectionState","attributes","useIsRecording","r","recordingStatusObservable"],"mappings":"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"}